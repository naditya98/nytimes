{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/adityanayak/Downloads/nytime/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/adityanayak/Downloads/nytime/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/adityanayak/Downloads/nytime/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/adityanayak/Downloads/nytime/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/adityanayak/Downloads/nytime/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _toConsumableArray from \"/Users/adityanayak/Downloads/nytime/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { compose, ScannedActionsSubject, Store, createAction, StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { merge, Observable, Subject, defer, Notification, pipe, of } from 'rxjs';\nimport { ignoreElements, materialize, map, catchError, filter, groupBy, mergeMap, exhaustMap, dematerialize, take, concatMap, finalize, withLatestFrom } from 'rxjs/operators';\nimport { Injectable, Inject, InjectionToken, ErrorHandler, NgModule, Optional, Injector, SkipSelf, Self } from '@angular/core';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'rxjs';\nimport * as ɵngcc2 from '@ngrx/store';\nvar DEFAULT_EFFECT_CONFIG = {\n  dispatch: true,\n  useEffectsErrorHandler: true\n};\nvar CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n/**\n * @description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * @param source A function which returns an `Observable`.\n * @param config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `useEffectsErrorHandler` is true.\n * @returns If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n * @usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n */\n\nfunction createEffect(source, config) {\n  var effect = source();\n  var value = Object.assign(Object.assign({}, DEFAULT_EFFECT_CONFIG), config);\n  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n    value: value\n  });\n  return effect;\n}\n\nfunction getCreateEffectMetadata(instance) {\n  var propertyNames = Object.getOwnPropertyNames(instance);\n  var metadata = propertyNames.filter(function (propertyName) {\n    if (instance[propertyName] && instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)) {\n      // If the property type has overridden `hasOwnProperty` we need to ensure\n      // that the metadata is valid (containing a `dispatch`property)\n      // https://github.com/ngrx/platform/issues/2975\n      var property = instance[propertyName];\n      return property[CREATE_EFFECT_METADATA_KEY].hasOwnProperty('dispatch');\n    }\n\n    return false;\n  }).map(function (propertyName) {\n    var metaData = instance[propertyName][CREATE_EFFECT_METADATA_KEY];\n    return Object.assign({\n      propertyName: propertyName\n    }, metaData);\n  });\n  return metadata;\n}\n\nfunction getSourceForInstance(instance) {\n  return Object.getPrototypeOf(instance);\n}\n\nvar METADATA_KEY = '__@ngrx/effects__';\n/**\n * @deprecated The Effect decorator (`@Effect`) is deprecated in favor for the `createEffect` method.\n * See the docs for more info {@link https://ngrx.io/guide/migration/v11#the-effect-decorator}\n */\n\nfunction Effect() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (target, propertyName) {\n    var metadata = Object.assign(Object.assign(Object.assign({}, DEFAULT_EFFECT_CONFIG), config), {\n      propertyName: propertyName\n    });\n    addEffectMetadataEntry(target, metadata);\n  };\n}\n\nfunction getEffectDecoratorMetadata(instance) {\n  var effectsDecorators = compose(getEffectMetadataEntries, getSourceForInstance)(instance);\n  return effectsDecorators;\n}\n/**\n * Type guard to detemine whether METADATA_KEY is already present on the Class\n * constructor\n */\n\n\nfunction hasMetadataEntries(sourceProto) {\n  return sourceProto.constructor.hasOwnProperty(METADATA_KEY);\n}\n/** Add Effect Metadata to the Effect Class constructor under specific key */\n\n\nfunction addEffectMetadataEntry(sourceProto, metadata) {\n  if (hasMetadataEntries(sourceProto)) {\n    sourceProto.constructor[METADATA_KEY].push(metadata);\n  } else {\n    Object.defineProperty(sourceProto.constructor, METADATA_KEY, {\n      value: [metadata]\n    });\n  }\n}\n\nfunction getEffectMetadataEntries(sourceProto) {\n  return hasMetadataEntries(sourceProto) ? sourceProto.constructor[METADATA_KEY] : [];\n}\n\nfunction getEffectsMetadata(instance) {\n  return getSourceMetadata(instance).reduce(function (acc, _ref) {\n    var propertyName = _ref.propertyName,\n        dispatch = _ref.dispatch,\n        useEffectsErrorHandler = _ref.useEffectsErrorHandler;\n    acc[propertyName] = {\n      dispatch: dispatch,\n      useEffectsErrorHandler: useEffectsErrorHandler\n    };\n    return acc;\n  }, {});\n}\n\nfunction getSourceMetadata(instance) {\n  var effects = [getEffectDecoratorMetadata, getCreateEffectMetadata];\n  return effects.reduce(function (sources, source) {\n    return sources.concat(source(instance));\n  }, []);\n}\n\nfunction mergeEffects(sourceInstance, globalErrorHandler, effectsErrorHandler) {\n  var sourceName = getSourceForInstance(sourceInstance).constructor.name;\n  var observables$ = getSourceMetadata(sourceInstance).map(function (_ref2) {\n    var propertyName = _ref2.propertyName,\n        dispatch = _ref2.dispatch,\n        useEffectsErrorHandler = _ref2.useEffectsErrorHandler;\n    var observable$ = typeof sourceInstance[propertyName] === 'function' ? sourceInstance[propertyName]() : sourceInstance[propertyName];\n    var effectAction$ = useEffectsErrorHandler ? effectsErrorHandler(observable$, globalErrorHandler) : observable$;\n\n    if (dispatch === false) {\n      return effectAction$.pipe(ignoreElements());\n    }\n\n    var materialized$ = effectAction$.pipe(materialize());\n    return materialized$.pipe(map(function (notification) {\n      return {\n        effect: sourceInstance[propertyName],\n        notification: notification,\n        propertyName: propertyName,\n        sourceName: sourceName,\n        sourceInstance: sourceInstance\n      };\n    }));\n  });\n  return merge.apply(void 0, _toConsumableArray(observables$));\n}\n\nvar MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\n\nfunction defaultEffectsErrorHandler(observable$, errorHandler) {\n  var retryAttemptLeft = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MAX_NUMBER_OF_RETRY_ATTEMPTS;\n  return observable$.pipe(catchError(function (error) {\n    if (errorHandler) errorHandler.handleError(error);\n\n    if (retryAttemptLeft <= 1) {\n      return observable$; // last attempt\n    } // Return observable that produces this particular effect\n\n\n    return defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft - 1);\n  }));\n}\n\nvar Actions = /*@__PURE__*/function () {\n  var Actions = /*#__PURE__*/function (_Observable) {\n    _inherits(Actions, _Observable);\n\n    var _super = _createSuper(Actions);\n\n    function Actions(source) {\n      var _this;\n\n      _classCallCheck(this, Actions);\n\n      _this = _super.call(this);\n\n      if (source) {\n        _this.source = source;\n      }\n\n      return _this;\n    }\n\n    _createClass(Actions, [{\n      key: \"lift\",\n      value: function lift(operator) {\n        var observable = new Actions();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n      }\n    }]);\n\n    return Actions;\n  }(Observable);\n\n  Actions.ɵfac = function Actions_Factory(t) {\n    return new (t || Actions)(ɵngcc0.ɵɵinject(ScannedActionsSubject));\n  };\n\n  Actions.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: Actions,\n    factory: Actions.ɵfac\n  });\n  return Actions;\n}();\n\nfunction ofType() {\n  for (var _len = arguments.length, allowedTypes = new Array(_len), _key = 0; _key < _len; _key++) {\n    allowedTypes[_key] = arguments[_key];\n  }\n\n  return filter(function (action) {\n    return allowedTypes.some(function (typeOrActionCreator) {\n      if (typeof typeOrActionCreator === 'string') {\n        // Comparing the string to type\n        return typeOrActionCreator === action.type;\n      } // We are filtering by ActionCreator\n\n\n      return typeOrActionCreator.type === action.type;\n    });\n  });\n}\n\nfunction reportInvalidActions(output, reporter) {\n  if (output.notification.kind === 'N') {\n    var action = output.notification.value;\n    var isInvalidAction = !isAction(action);\n\n    if (isInvalidAction) {\n      reporter.handleError(new Error(\"Effect \".concat(getEffectName(output), \" dispatched an invalid action: \").concat(stringify(action))));\n    }\n  }\n}\n\nfunction isAction(action) {\n  return typeof action !== 'function' && action && action.type && typeof action.type === 'string';\n}\n\nfunction getEffectName(_ref3) {\n  var propertyName = _ref3.propertyName,\n      sourceInstance = _ref3.sourceInstance,\n      sourceName = _ref3.sourceName;\n  var isMethod = typeof sourceInstance[propertyName] === 'function';\n  return \"\\\"\".concat(sourceName, \".\").concat(String(propertyName)).concat(isMethod ? '()' : '', \"\\\"\");\n}\n\nfunction stringify(action) {\n  try {\n    return JSON.stringify(action);\n  } catch (_a) {\n    return action;\n  }\n}\n\nvar onIdentifyEffectsKey = 'ngrxOnIdentifyEffects';\n\nfunction isOnIdentifyEffects(instance) {\n  return isFunction(instance, onIdentifyEffectsKey);\n}\n\nvar onRunEffectsKey = 'ngrxOnRunEffects';\n\nfunction isOnRunEffects(instance) {\n  return isFunction(instance, onRunEffectsKey);\n}\n\nvar onInitEffects = 'ngrxOnInitEffects';\n\nfunction isOnInitEffects(instance) {\n  return isFunction(instance, onInitEffects);\n}\n\nfunction isFunction(instance, functionName) {\n  return instance && functionName in instance && typeof instance[functionName] === 'function';\n}\n\nvar _ROOT_EFFECTS_GUARD = new InjectionToken('@ngrx/effects Internal Root Guard');\n\nvar USER_PROVIDED_EFFECTS = new InjectionToken('@ngrx/effects User Provided Effects');\n\nvar _ROOT_EFFECTS = new InjectionToken('@ngrx/effects Internal Root Effects');\n\nvar ROOT_EFFECTS = new InjectionToken('@ngrx/effects Root Effects');\n\nvar _FEATURE_EFFECTS = new InjectionToken('@ngrx/effects Internal Feature Effects');\n\nvar FEATURE_EFFECTS = new InjectionToken('@ngrx/effects Feature Effects');\nvar EFFECTS_ERROR_HANDLER = new InjectionToken('@ngrx/effects Effects Error Handler');\n\nvar EffectSources = /*@__PURE__*/function () {\n  var EffectSources = /*#__PURE__*/function (_Subject) {\n    _inherits(EffectSources, _Subject);\n\n    var _super2 = _createSuper(EffectSources);\n\n    function EffectSources(errorHandler, effectsErrorHandler) {\n      var _this2;\n\n      _classCallCheck(this, EffectSources);\n\n      _this2 = _super2.call(this);\n      _this2.errorHandler = errorHandler;\n      _this2.effectsErrorHandler = effectsErrorHandler;\n      return _this2;\n    }\n\n    _createClass(EffectSources, [{\n      key: \"addEffects\",\n      value: function addEffects(effectSourceInstance) {\n        this.next(effectSourceInstance);\n      }\n      /**\n       * @internal\n       */\n\n    }, {\n      key: \"toActions\",\n      value: function toActions() {\n        var _this3 = this;\n\n        return this.pipe(groupBy(getSourceForInstance), mergeMap(function (source$) {\n          return source$.pipe(groupBy(effectsInstance));\n        }), mergeMap(function (source$) {\n          var effect$ = source$.pipe(exhaustMap(function (sourceInstance) {\n            return resolveEffectSource(_this3.errorHandler, _this3.effectsErrorHandler)(sourceInstance);\n          }), map(function (output) {\n            reportInvalidActions(output, _this3.errorHandler);\n            return output.notification;\n          }), filter(function (notification) {\n            return notification.kind === 'N' && notification.value != null;\n          }), dematerialize()); // start the stream with an INIT action\n          // do this only for the first Effect instance\n\n          var init$ = source$.pipe(take(1), filter(isOnInitEffects), map(function (instance) {\n            return instance.ngrxOnInitEffects();\n          }));\n          return merge(effect$, init$);\n        }));\n      }\n    }]);\n\n    return EffectSources;\n  }(Subject);\n\n  EffectSources.ɵfac = function EffectSources_Factory(t) {\n    return new (t || EffectSources)(ɵngcc0.ɵɵinject(ɵngcc0.ErrorHandler), ɵngcc0.ɵɵinject(EFFECTS_ERROR_HANDLER));\n  };\n\n  EffectSources.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: EffectSources,\n    factory: EffectSources.ɵfac\n  });\n  return EffectSources;\n}();\n\nfunction effectsInstance(sourceInstance) {\n  if (isOnIdentifyEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnIdentifyEffects();\n  }\n\n  return '';\n}\n\nfunction resolveEffectSource(errorHandler, effectsErrorHandler) {\n  return function (sourceInstance) {\n    var mergedEffects$ = mergeEffects(sourceInstance, errorHandler, effectsErrorHandler);\n\n    if (isOnRunEffects(sourceInstance)) {\n      return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n    }\n\n    return mergedEffects$;\n  };\n}\n\nvar EffectsRunner = /*@__PURE__*/function () {\n  var EffectsRunner = /*#__PURE__*/function () {\n    function EffectsRunner(effectSources, store) {\n      _classCallCheck(this, EffectsRunner);\n\n      this.effectSources = effectSources;\n      this.store = store;\n      this.effectsSubscription = null;\n    }\n\n    _createClass(EffectsRunner, [{\n      key: \"start\",\n      value: function start() {\n        if (!this.effectsSubscription) {\n          this.effectsSubscription = this.effectSources.toActions().subscribe(this.store);\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.effectsSubscription) {\n          this.effectsSubscription.unsubscribe();\n          this.effectsSubscription = null;\n        }\n      }\n    }]);\n\n    return EffectsRunner;\n  }();\n\n  EffectsRunner.ɵfac = function EffectsRunner_Factory(t) {\n    return new (t || EffectsRunner)(ɵngcc0.ɵɵinject(EffectSources), ɵngcc0.ɵɵinject(ɵngcc2.Store));\n  };\n\n  EffectsRunner.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: EffectsRunner,\n    factory: EffectsRunner.ɵfac\n  });\n  return EffectsRunner;\n}();\n\nvar ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nvar rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\n\nvar EffectsRootModule = /*@__PURE__*/function () {\n  var EffectsRootModule = /*#__PURE__*/function () {\n    function EffectsRootModule(sources, runner, store, rootEffects, storeRootModule, storeFeatureModule, guard) {\n      _classCallCheck(this, EffectsRootModule);\n\n      this.sources = sources;\n      runner.start();\n      rootEffects.forEach(function (effectSourceInstance) {\n        return sources.addEffects(effectSourceInstance);\n      });\n      store.dispatch({\n        type: ROOT_EFFECTS_INIT\n      });\n    }\n\n    _createClass(EffectsRootModule, [{\n      key: \"addEffects\",\n      value: function addEffects(effectSourceInstance) {\n        this.sources.addEffects(effectSourceInstance);\n      }\n    }]);\n\n    return EffectsRootModule;\n  }();\n\n  EffectsRootModule.ɵfac = function EffectsRootModule_Factory(t) {\n    return new (t || EffectsRootModule)(ɵngcc0.ɵɵinject(EffectSources), ɵngcc0.ɵɵinject(EffectsRunner), ɵngcc0.ɵɵinject(ɵngcc2.Store), ɵngcc0.ɵɵinject(ROOT_EFFECTS), ɵngcc0.ɵɵinject(ɵngcc2.StoreRootModule, 8), ɵngcc0.ɵɵinject(ɵngcc2.StoreFeatureModule, 8), ɵngcc0.ɵɵinject(_ROOT_EFFECTS_GUARD, 8));\n  };\n\n  EffectsRootModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: EffectsRootModule\n  });\n  EffectsRootModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return EffectsRootModule;\n}();\n\nvar EffectsFeatureModule = /*@__PURE__*/function () {\n  var EffectsFeatureModule = function EffectsFeatureModule(root, effectSourceGroups, storeRootModule, storeFeatureModule) {\n    _classCallCheck(this, EffectsFeatureModule);\n\n    effectSourceGroups.forEach(function (group) {\n      return group.forEach(function (effectSourceInstance) {\n        return root.addEffects(effectSourceInstance);\n      });\n    });\n  };\n\n  EffectsFeatureModule.ɵfac = function EffectsFeatureModule_Factory(t) {\n    return new (t || EffectsFeatureModule)(ɵngcc0.ɵɵinject(EffectsRootModule), ɵngcc0.ɵɵinject(FEATURE_EFFECTS), ɵngcc0.ɵɵinject(ɵngcc2.StoreRootModule, 8), ɵngcc0.ɵɵinject(ɵngcc2.StoreFeatureModule, 8));\n  };\n\n  EffectsFeatureModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: EffectsFeatureModule\n  });\n  EffectsFeatureModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return EffectsFeatureModule;\n}();\n\nvar EffectsModule = /*@__PURE__*/function () {\n  var EffectsModule = /*#__PURE__*/function () {\n    function EffectsModule() {\n      _classCallCheck(this, EffectsModule);\n    }\n\n    _createClass(EffectsModule, null, [{\n      key: \"forFeature\",\n      value: function forFeature() {\n        var featureEffects = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        return {\n          ngModule: EffectsFeatureModule,\n          providers: [featureEffects, {\n            provide: _FEATURE_EFFECTS,\n            multi: true,\n            useValue: featureEffects\n          }, {\n            provide: USER_PROVIDED_EFFECTS,\n            multi: true,\n            useValue: []\n          }, {\n            provide: FEATURE_EFFECTS,\n            multi: true,\n            useFactory: createEffects,\n            deps: [Injector, _FEATURE_EFFECTS, USER_PROVIDED_EFFECTS]\n          }]\n        };\n      }\n    }, {\n      key: \"forRoot\",\n      value: function forRoot() {\n        var rootEffects = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        return {\n          ngModule: EffectsRootModule,\n          providers: [{\n            provide: EFFECTS_ERROR_HANDLER,\n            useValue: defaultEffectsErrorHandler\n          }, EffectsRunner, EffectSources, Actions, rootEffects, {\n            provide: _ROOT_EFFECTS,\n            useValue: [rootEffects]\n          }, {\n            provide: _ROOT_EFFECTS_GUARD,\n            useFactory: _provideForRootGuard,\n            deps: [[EffectsRunner, new Optional(), new SkipSelf()], [_ROOT_EFFECTS, new Self()]]\n          }, {\n            provide: USER_PROVIDED_EFFECTS,\n            multi: true,\n            useValue: []\n          }, {\n            provide: ROOT_EFFECTS,\n            useFactory: createEffects,\n            deps: [Injector, _ROOT_EFFECTS, USER_PROVIDED_EFFECTS]\n          }]\n        };\n      }\n    }]);\n\n    return EffectsModule;\n  }();\n\n  EffectsModule.ɵfac = function EffectsModule_Factory(t) {\n    return new (t || EffectsModule)();\n  };\n\n  EffectsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: EffectsModule\n  });\n  EffectsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return EffectsModule;\n}();\n\nfunction createEffects(injector, effectGroups, userProvidedEffectGroups) {\n  var mergedEffects = [];\n\n  var _iterator = _createForOfIteratorHelper(effectGroups),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var effectGroup = _step.value;\n      mergedEffects.push.apply(mergedEffects, _toConsumableArray(effectGroup));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(userProvidedEffectGroups),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var userProvidedEffectGroup = _step2.value;\n      mergedEffects.push.apply(mergedEffects, _toConsumableArray(userProvidedEffectGroup));\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return createEffectInstances(injector, mergedEffects);\n}\n\nfunction createEffectInstances(injector, effects) {\n  return effects.map(function (effect) {\n    return injector.get(effect);\n  });\n}\n\nfunction _provideForRootGuard(runner, rootEffects) {\n  // check whether any effects are actually passed\n  var hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);\n\n  if (hasEffects && runner) {\n    throw new TypeError(\"EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.\");\n  }\n\n  return 'guarded';\n}\n\nfunction act(\n/** Allow to take either config object or project/error functions */\nconfigOrProject, errorFn) {\n  var _ref4 = typeof configOrProject === 'function' ? {\n    project: configOrProject,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    error: errorFn,\n    operator: concatMap,\n    complete: undefined,\n    unsubscribe: undefined\n  } : Object.assign(Object.assign({}, configOrProject), {\n    operator: configOrProject.operator || concatMap\n  }),\n      project = _ref4.project,\n      error = _ref4.error,\n      complete = _ref4.complete,\n      operator = _ref4.operator,\n      unsubscribe = _ref4.unsubscribe;\n\n  return function (source) {\n    return defer(function () {\n      var subject = new Subject();\n      return merge(source.pipe(operator(function (input, index) {\n        return defer(function () {\n          var completed = false;\n          var errored = false;\n          var projectedCount = 0;\n          return project(input, index).pipe(materialize(), map(function (notification) {\n            switch (notification.kind) {\n              case 'E':\n                errored = true;\n                return new Notification('N', error(notification.error, input));\n\n              case 'C':\n                completed = true;\n                return complete ? new Notification('N', complete(projectedCount, input)) : undefined;\n\n              default:\n                ++projectedCount;\n                return notification;\n            }\n          }), filter(function (n) {\n            return n != null;\n          }), dematerialize(), finalize(function () {\n            if (!completed && !errored && unsubscribe) {\n              subject.next(unsubscribe(projectedCount, input));\n            }\n          }));\n        });\n      })), subject);\n    });\n  };\n}\n/**\n * 'concatLatestFrom' combines the source value\n * and the last available value from a lazily evaluated Observable\n * in a new array\n */\n\n\nfunction concatLatestFrom(observablesFactory) {\n  return pipe(concatMap(function (value) {\n    var observables = observablesFactory(value);\n    var observablesAsArray = Array.isArray(observables) ? observables : [observables];\n    return of(value).pipe(withLatestFrom.apply(void 0, _toConsumableArray(observablesAsArray)));\n  }));\n}\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Actions, EFFECTS_ERROR_HANDLER, Effect, EffectSources, EffectsFeatureModule, EffectsModule, EffectsRootModule, EffectsRunner, ROOT_EFFECTS_INIT, USER_PROVIDED_EFFECTS, act, concatLatestFrom, createEffect, defaultEffectsErrorHandler, getEffectsMetadata, mergeEffects, ofType, rootEffectsInit, getSourceMetadata as ɵa, createEffects as ɵb, _provideForRootGuard as ɵc, _ROOT_EFFECTS_GUARD as ɵd, _ROOT_EFFECTS as ɵe, ROOT_EFFECTS as ɵf, _FEATURE_EFFECTS as ɵg, FEATURE_EFFECTS as ɵh }; //# sourceMappingURL=ngrx-effects.js.map","map":null,"metadata":{},"sourceType":"module"}